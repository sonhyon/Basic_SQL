[SQL 프로그래밍]
[IF문]
SELECT STORE_ID, IF(STORE_ID=1, '일', '이') AS ONE_TWO
FROM CUSTOMER 
GROUP BY STORE_ID;

#IF문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_IF;

DELIMITER $$
CREATE PROCEDURE DOIT_IF (CUSTOMER_ID_INPUT INT)
BEGIN
DECLARE STORE_ID_I INT;
  DECLARE S_ID_ONE INT;
  DECLARE S_ID_TWO INT;

  SET STORE_ID_I = (SELECT STORE_ID FROM CUSTOMER WHERE CUSTOMER_ID = CUSTOMER_ID_INPUT);

  IF STORE_ID_I = 1 THEN SET S_ID_ONE = 1;
  ELSE SET S_ID_TWO = 2;
  END IF;
  SELECT STORE_ID_I, S_ID_ONE, S_ID_TWO;

END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_IF(1);


[CASE 문]
#CASE 문을 활용한 데이터 조회
SELECT CUSTOMER_ID, SUM(AMOUNT) AS AMOUNT
  CASE
    WHEN SUM(AMOUNT) >= 150 THEN 'VVIP'
    WHEN SUM(AMOUNT) >= 120 THEN 'VIP'
    WHEN SUM(AMOUNT) >= 150 THEN 'GOLD'
    WHEN SUM(AMOUNT) >= 150 THEN 'SILVER'
    ELSE 'BRONZE'
  END AS CUSTOMER_LEVEL
FROM PAYMENT GROUP BY CUSTOMER_ID;

#CASE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_CASE;

DELIMITER $$
CREATE PROCEDURE DOIT_CASE (CUSTOMER_ID_INPUT INT)
BEGIN
  DECLARE CUSTOMER_LEVEL VARCHAR(10);
  DECLARE AMOUNT_SUM FLOAT;

  SET AMOUNT_SUM = (SELECT SUM(AMOUNT) FROM PAYMENT WHERE CUSTOMER_ID = CUSTOEMR_IDINPUT GROUP BY CUSTOMER_ID);

  CASE
    WHEN SUM(AMOUNT) >= 150 THEN 'VVIP'
    WHEN SUM(AMOUNT) >= 120 THEN 'VIP'
    WHEN SUM(AMOUNT) >= 150 THEN 'GOLD'
    WHEN SUM(AMOUNT) >= 150 THEN 'SILVER'
    ELSE SET CUSTOMER_LEVEL = 'BRONZE';
  END CASE;
  SELECT CUSTOMER_ID_INPUT AS CUSTOMER_ID, AMOUNT_SUM, CUSTOMER_LEVEL;

END $$
DELIMITER

#스토어드 프로시저 실행
CALL DOIT_CASE(4)

[WHILE 문]
#WHILE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_WHILE;

DELIMITER $$
CREATE PRODECURE DOIT_WHILE (PARAM_1 INT, PARAM_2 INT)
BEGIN
  DECLARE I INT;
  DECLARE WHILE_SUM INT;

  SET I = 1;
  SET WHILE_SUM = 0;

  WHILE (I <= PARAM_1) DO
    SET WHILE_SUM = WHILE_SUM + PARAM_2;
    SET I = I + 1;
  END WHILE;
  SELECT WHILE_SUM;

END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_WHILE(10, 3)

#WHILE~LEAVE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_WHILE;

DELIMITER $$
CREATE PROCEDURE DOIT_WHILE (PARAM_1 INT, PARAM_2 INT)
BEGIN
  DECLARE I INT;
  DECLARE WHILE_SUM INT;

  SET I = 1;
  SET WHILE_SUM = 0;

  MYWHILE:
  WHILE (I <= PARAM_1) DO
    SET WHILE_SUM = WHILE_SUM + PARAM_2;
    SET I = I + 1;

    IF (WHILE_SUM > 100) THEN LEAVE MYWHILE;
    END IF;
  END WHILE;
  SELECT WHILE_SUM;
END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_WHILE(1000, 3)


[동적 SQL]
- 변숫값을 할당 받아 MySQL 서버 내부 또는 스토어드 프로시저에서 쿼리를 재작성하는 것

#동적 SQL을 활용한 데이터 조회
PREPARE DYNAMIC_QUERY FROM 'SELECT * FROM CUSTOMER WHERE CUSTOMER_ID = ?';
SET @A = 1;
EXECUTE DYNAMIC_QUERY USING @A;
DEALLOCATE PREPARE DYNAMIC_QUERY;

#동적 SQL을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_DYNAMIC;

DELIMITER $$
CREATE PROCEDURE DOIT_DYNAMIC (T_NAME VARCHAR(50), C_NAME VARCHAR(50), CUSTOMER_ID INT)
BEGIN
  SET @T_NMAE = T_NAME;
  SET @C_NAME = C_NAME;
  SET @CUSTOMER_ID = CUSTOMER_ID;
  SET @SQL = CONCAT('SELECT ', @C_NAME, ' FROM', @T_NAME, ' WHERE CUSTOMER_ID =', @CUSTOMER_ID);
  SELECT @SQL;
  PREPARE DYNAMIC_QUERY FROM @SQL;
  EXECUTE DYNAMIC_QUERY;
  DEALLOCATE PREPARE DYNAMIC_QUERY;
END $$
DELIMITER ;

#스토어드 프로시저 실행
CALL DOIT_DYNAMIC('PAYMENT', '*', 1);
  

[인덱스]
#인덱스의 종류: 클러스터형 인덱스, 비클러스터형 인덱스

#인덱스 생성 및 삭제하기
1. 실습을 위한 테이블과 데이터 생성
USE DOITSQL;

DROP TABLE IF EXISTS DOIT_CLUSTERINDEX;
CREATE TABLE DOIT_CLUSTRINDEX (
COL_1 INT,
COL_2 VARCHAR(50),
COL_3 VARCHAR(50)
);

INSERT INTO DOIT_CLUSTERINDEX VALUES (2, '사자', 'LION');
INSERT INTO DOIT_CLUSTERINDEX VALUES (5, '호랑이', 'TIGER');
INSERT INTO DOIT_CLUSTERINDEX VALUES (3, '얼룩말', ZBERA');
INSERT INTO DOIT_CLUSTERINDEX VALUES (4, '코뿔소', 'RHINOCEROS');
INSERT INTO DOIT_CLUSTERINDEX VALUES (1, '거북이', 'TURTLE');

SELECT * FROM DOIT_CLUSTERINDEX;

2. 기본키(기본 인덱스) 생성
ALTER TABLE DOIT_CLUSTERINDEX
  ADD CONSTRAINT KEY (COL_1);

SELECT * FROM DOIT_CLUSTERINDEX;

3. 새로운 데이터 입력
INSERT INTO DOIT_CLUSTERINDEX VALUES (0, '물고기', 'FISH');
SELECT * FROM DOIT_CLUSTERINDEX;

4. COL_2 열로 인덱스 변경
ALTER TABLE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY DOIT_CLUSTERINDEX (COL_2);

SELECT * FROM DOIT_CLUSTERINDEX;

5. COL_3 열로 인덱스 변경
ALTER TALBE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY (COL_3);

SELECT * FROM DOIT_CLUSTERINDEX;

6. 복합키 인덱스 생성
ALTER TABLE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY (COL_1, COL_3);

SHOW INDEX FROM DOIT_CLUSTERINDEX;

7. 인덱스 삭제
ALTER TABLE DOIR_CLUSTERINDEX DROP PRIMARY KEY;

SHOW INDEX FROM DOIT_CLUSTERINDEX;


#비클러스터형 인덱스 생성과 삭제 방법
1. 실습을 위한 테이블과 데이터 생성
USE DOITSQL;

DROP TABLE IF EXISTS DOIT_NONCLUSTERINDEX;
CREATE TABLE DOTI_NONCLUSTERINDEX (
COL_1 INT,
COL_2 VARCHAR(50),
COL_3 VARCHAR(50)
);

INSERT INTO DOIT_NONCLUSTERINDEX VALUES (2, '사자', 'LION');
INSERT INTO DOIT_NONCLUSTERINDEX VALUES (5, '호랑이', TIGER');
INSERT INTO DOIT_NONCLUSTERINDEX VALUES (3, '얼굴말', 'ZBERA');
INSERT INTO DOIT_NONCLUSTERINDEX VALUES (4, '코뿔소', RHINOCEROS');
INSERT INTO DOIT_NONCLUSTERINDEX VALUES (1, '거북이', TURTLE');

SELECT * FROM DOIT_NONCLUSTERINDEX;

2. 비클러스터형 인덱스 생성
CREATE INDEX IX_DOIT_NONCLUSTERINDEX_1 ON DOIT_NONCLUSTERINDEX (COL_1);
SELECT * FROM DOIT_NONCLUSTERINDEX;

3. 새로운 데이터 입력
INSERT INTO DOIT_NONCLUSTERINDEX VALUES (0, '물고기', 'FISH');
SELECT * FROM DOIT_NONCLUSTERINDEX;

4. 각 열별로 인덱스 생성
CREATE INDEX IX_DOIT_NONCLUSTERINDEX_2 ON DOIT_NONCLUSTERINDEX (COL_2);
CREATE INDEX IX_DOIT_NONCLUSTERINDEX_3 ON DOIT_NONCLUSTERINDEX (COL_3);

SELECT * FROM DOIT_NONCLUSTERINDEX;

복합키 인덱스 생성
CREATE INDEX IX_DOIT_NONCLUSTERINDEX_1_2 ON DOIT_NONCLUSTERINDEX (COL_1, COL_2);
CREATE INDEX IX_DOIT_NONCLUSTERINDEX_1_3 ON DOIT_NONCLUSTERINDEX (COL_1, COL_3);

SHOW INDEX FROM DOIT_NONCLUSTERINDEX;

6. 인덱스 삭제
DROP INDEX IX_DOIT_NONCLUSTERINDEX_1_2 ON DOIT_NONCLUSTERINDEX;
DROP INDEX IX_DOIT_NONCLUSTERINDEX_1_3 ON DOIT_NONCLUSTERINDEX;

SHOW INDEX FROM DOIT_NONCLUSTERINDEX;


[뷰]
뷰(View)는 데이터베이스에 존재하는 가상의 테이블 (종류: 단일뷰, 복합뷰)

장점: 복잡한 쿼리를 단축, 보안성 우수
단점: 한 번 정의된 뷰는 변경x, 제한 사항이 있음, 인덱스 가질 수 없다

#뷰 생성 및 조회하기
1. 뷰 생성 기본 형식
CREATE VIEW 뷰 이름
AS
  <SELECT 문>

CREATE VIEW V_CUSTOMER
AS
  SELECT FIRST_NAME, LAST_NAME, EMAIL FROM CUSTOMER;
SELECT * FROM V_CUSTOMER;

2. 2개의 테이블을 조인해 원하는 데이터를 보여주는 뷰 생성
CREATE VIEW V_PAYUSER
AS
  SELECT FIRST_NAME, LAST_NAME, EMAIL, AMOUNT, ADDRESS_ID
  FROM CUSTOMER AS A
    INNER JOIN (SELECT CUSTOMER_ID, SUM(AMOUNT) AS AMOUNT FROM PAYMENT
    GROUP BY CUSTOMER_ID) AS B ON A.CUSTOMER_ID = B.CUSTOMER_ID;
SELECT * FROM V_PAYUSER;

3. 뷰 테이블과 일반 테이블 조인
SELECT A.*, B.*
FROM V_PAYUSER AS A
  INNER JOIN ADDRESS AS B ON A.ADDRESS_ID = B.ADDRESS_ID;

#뷰 수정하기
1. 뷰 수정
ALTER VIEW V_CUSTOMER
AS
  SELECT CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, ADDRESS_ID
  FROM CUSTOEMR;
SELECT * FROM V_CUSTOMER;

2. V_CUSTOMER뷰 생성 및 교체
CREATE OR REPLACE VIEW V_CUSTOMER
AS
  SELECT '뷰가 이미 있으면 수정, 없으면 생성';
SELECT * FROM V_CUSTOMER;

#뷰 정보 확인하기
1. 뷰 정보 확인
DESCRIBE V_PAYUSER;

2. SQL문으로 뷰 정보 확인
SHOW CREATE VIEW V_PAYUSER;

#뷰 삭제하기
DROP VIEW V_CUSTOMER;
DROP VIEW V_PAYUSER;

#뷰를 사용해 데이터 조작하기
1. 테이블과 뷰 생성
CREATE TABLE TBL_A (
COL_1 INT NOT NULL,
COL_2 VARCHAR(50) NOT NULL
);

CREATE TABLE TBL_B (
COL_1 INT NOT NULL,
COL_2 VARCHAR(50) NOT NULL
);

INSERT INTO TBL_A VALUES(1, 'TBL_A_1');
INSERT INTO TBL_A VALUES(1, 'TBL_A_2');
INSERT INTO TBL_B VALUES(1, 'TBL_A_1');
INSERT INTO TBL_B VALUES(1, 'TBL_A_2');

CREATE VIEW V_TBL_A
AS
  SELECT COL_1, COL_2 FROM TBL_A;
SELECT * FROM V_TBL_A;

2. 단일 뷰 데이터 수정
SET SQL_SAFE_UPDATES = 0;
UPDATE V_TBL_A SET COL_2 = 'TBL_A 열 수정'
WHERE COL_1 = 1;
SELECT * FROM V_TBL_A;

3. 단일 뷰 데이터 추가
INSERT V_TBL_A VALUES (3, 'TBL_A_3');
SELECT * FROM V_TBL_A;

4. 단일 뷰 데이터 삭제
DELETE FROM V_TBL_A WHERE COL_1 = 3;
SELECT * FROM V_TBL_A;

5. 새로운 뷰 생성 후 데이터 추가
CREATE VIEW V_TBL_A2
AS
  SELECT COL_1 FROM TBL_A;
INSERT V_TBL_A2 VALUES (5);

6. 복합 뷰 생성
CREATE VIEW V_TBL_A_B
AS
  SELECT
    A.COL_1 AS A_COL_1,
    A.COL_2 AS A_COL_2,
    A.COL_2 AS B_COL_2,
  FROM TBL_A AS A
    INNER JOIN TBL_B AS B ON A.COL_1 = B.COL_1;
SELECT * FROM V_TBL_A_B;

7. 복합 뷰 데이터 수정
UPDATE V_TBL_A_B SET A_COL_2 = 'TBL_A 컬럼 수정', B_COL_2 = 'TBL_B 컬럼 수정'
WHERE A_COL_1 = 1;

8. 복합 뷰 데이터 입력
INSERT V_TBL_A_B VALUES (3, 'TBL_A_3', 'TBL_B_3');

9. 참조 데이터 삭제
DROP TABLE TBL_A;

10. 뷰 정보 확인
CHECK TABLE_A_B;


[스토어드 함수와 커서]
#스토어드 함수 이해하기
1. 함수 생성 권한 부여
SET GLOBAL LOG_BIN_TRUST_FUNCTION_CREATORS = 1;

2. 스토어드 함수 생성
USE DOITSQL;
DROP FUNCTION IF EXISTS USER_SUM;

DELIMITER $$
CREATE FUNCTION USER_SUM(NUM_1 INT, NUM_2 INT)
  RETURNS INT
BEGIN
  RETURN NUM_1 + NUM_2;
END $$
DELIMITER;

#스토어드 함수 사용하기
SELECT USER_SUM (1, 5);

#스토어드 함수 내용 확인 및 삭제하기
1. 스토어드 함수 내용 확인
SHOW CREATE FUNCTION USER_SUM;

2. 스토어드함수 삭제
DROP FUNCTION USER_SUM;

#커서 알아두기


[트리거]
#트리거의 종류
- 행 트리거
- 문장 트리거

#트리거 실행 시기

#트리거 실행하기
1. 테이블 생성
USE DOITSQL;

CREATE TABLE TBL_TRIGGER_1 (
COL_1 INT,
COL_2 VARCHAR(50)
);

CREATE TABLE TBL_TRIGGER_2 (
COL_1 INT,
COL_2 VARCHAR(50)
);

INSERT INTO TBL_TRIGGER_1 VALUES (1, '데이터 1 입력');
SELECT * FROM TBL_TRIGGER_1;

2. UPDATE 발생 시 동작하는 트리거 생성
DELIMITER $$

CREATE TRIGGER DOT_UPDATE_TRIGGER
ALTER UPDATE
ON TBL_TRIGGER_1
FRO EACH SHOW

BEGIN
  INSERT INTO TBL_TRIGGER_2 VALUES (OLD.COL1, OLD.COL_2);

END $$
DELIMITER;

#트리거 생성
SET SQL_SAFE_UPDATE = 0;
UPDATE TBL_TRIGGER_1 SET COL_1 = 2, COL_2 = '1을 2로 수정';

SELECT * FROM TBL_TRIGGER_2;
SELECT * FROM TBL_TRIGGER_1;
