[스튜어드 프로시저]
스튜어드 프로시저 : 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합

장정 : 재사용할 수 있어 편리하다
단점 : 다른 프로그래밍 언어에 비해 느리다, 다른 제품과 호환성이 낮다

#스토어드 프로시저 생성하기
DELIMITER $$
CREATE PROCEDURE DOIT_PROC()
BEGIN
  DECLARE CUSTOMER_CNT INT;
  DECLARE ADD_NUMBER INT;

  SET CUSTOMER_CNT = 0;
  SET ADD_NUMBER = 100;

  SET CUSTOMER_CNT = (SELECT COUNT(*) FROM CUSTOMER);

  SELECT CUSTOMER_CNT + ADD_NUMBER;

END $$
DELIMITER;

#스토어드 프로시저 호출하기
CALL DOIT_PROC();

#스토어드 프로시저 내용 확인하기
SHOW CREATE PROCEDURE DOIT_PROC;

#스토어드 프로시저 삭제하기
DROP PROCEDURE DOIT_PROC;


[SQL 프로그래밍]
[IF문]
SELECT STORE_ID, IF(STORE_ID=1, '일', '이') AS ONE_TWO
FROM CUSTOMER 
GROUP BY STORE_ID;

#IF문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_IF;

DELIMITER $$
CREATE PROCEDURE DOIT_IF (CUSTOMER_ID_INPUT INT)
BEGIN
DECLARE STORE_ID_I INT;
  DECLARE S_ID_ONE INT;
  DECLARE S_ID_TWO INT;

  SET STORE_ID_I = (SELECT STORE_ID FROM CUSTOMER WHERE CUSTOMER_ID = CUSTOMER_ID_INPUT);

  IF STORE_ID_I = 1 THEN SET S_ID_ONE = 1;
  ELSE SET S_ID_TWO = 2;
  END IF;
  SELECT STORE_ID_I, S_ID_ONE, S_ID_TWO;

END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_IF(1);


[CASE 문]
#CASE 문을 활용한 데이터 조회
SELECT CUSTOMER_ID, SUM(AMOUNT) AS AMOUNT
  CASE
    WHEN SUM(AMOUNT) >= 150 THEN 'VVIP'
    WHEN SUM(AMOUNT) >= 120 THEN 'VIP'
    WHEN SUM(AMOUNT) >= 150 THEN 'GOLD'
    WHEN SUM(AMOUNT) >= 150 THEN 'SILVER'
    ELSE 'BRONZE'
  END AS CUSTOMER_LEVEL
FROM PAYMENT GROUP BY CUSTOMER_ID;

#CASE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_CASE;

DELIMITER $$
CREATE PROCEDURE DOIT_CASE (CUSTOMER_ID_INPUT INT)
BEGIN
  DECLARE CUSTOMER_LEVEL VARCHAR(10);
  DECLARE AMOUNT_SUM FLOAT;

  SET AMOUNT_SUM = (SELECT SUM(AMOUNT) FROM PAYMENT WHERE CUSTOMER_ID = CUSTOEMR_IDINPUT GROUP BY CUSTOMER_ID);

  CASE
    WHEN SUM(AMOUNT) >= 150 THEN 'VVIP'
    WHEN SUM(AMOUNT) >= 120 THEN 'VIP'
    WHEN SUM(AMOUNT) >= 150 THEN 'GOLD'
    WHEN SUM(AMOUNT) >= 150 THEN 'SILVER'
    ELSE SET CUSTOMER_LEVEL = 'BRONZE';
  END CASE;
  SELECT CUSTOMER_ID_INPUT AS CUSTOMER_ID, AMOUNT_SUM, CUSTOMER_LEVEL;

END $$
DELIMITER

#스토어드 프로시저 실행
CALL DOIT_CASE(4)

[WHILE 문]
#WHILE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_WHILE;

DELIMITER $$
CREATE PRODECURE DOIT_WHILE (PARAM_1 INT, PARAM_2 INT)
BEGIN
  DECLARE I INT;
  DECLARE WHILE_SUM INT;

  SET I = 1;
  SET WHILE_SUM = 0;

  WHILE (I <= PARAM_1) DO
    SET WHILE_SUM = WHILE_SUM + PARAM_2;
    SET I = I + 1;
  END WHILE;
  SELECT WHILE_SUM;

END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_WHILE(10, 3)

#WHILE~LEAVE 문을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_WHILE;

DELIMITER $$
CREATE PROCEDURE DOIT_WHILE (PARAM_1 INT, PARAM_2 INT)
BEGIN
  DECLARE I INT;
  DECLARE WHILE_SUM INT;

  SET I = 1;
  SET WHILE_SUM = 0;

  MYWHILE:
  WHILE (I <= PARAM_1) DO
    SET WHILE_SUM = WHILE_SUM + PARAM_2;
    SET I = I + 1;

    IF (WHILE_SUM > 100) THEN LEAVE MYWHILE;
    END IF;
  END WHILE;
  SELECT WHILE_SUM;
END $$
DELIMITER;

#스토어드 프로시저 실행
CALL DOIT_WHILE(1000, 3)


[동적 SQL]
- 변숫값을 할당 받아 MySQL 서버 내부 또는 스토어드 프로시저에서 쿼리를 재작성하는 것

#동적 SQL을 활용한 데이터 조회
PREPARE DYNAMIC_QUERY FROM 'SELECT * FROM CUSTOMER WHERE CUSTOMER_ID = ?';
SET @A = 1;
EXECUTE DYNAMIC_QUERY USING @A;
DEALLOCATE PREPARE DYNAMIC_QUERY;

#동적 SQL을 실행하기 위한 스토어드 프로시저 생성
DROP PROCEDURE IF EXISTS DOIT_DYNAMIC;

DELIMITER $$
CREATE PROCEDURE DOIT_DYNAMIC (T_NAME VARCHAR(50), C_NAME VARCHAR(50), CUSTOMER_ID INT)
BEGIN
  SET @T_NMAE = T_NAME;
  SET @C_NAME = C_NAME;
  SET @CUSTOMER_ID = CUSTOMER_ID;
  SET @SQL = CONCAT('SELECT ', @C_NAME, ' FROM', @T_NAME, ' WHERE CUSTOMER_ID =', @CUSTOMER_ID);
  SELECT @SQL;
  PREPARE DYNAMIC_QUERY FROM @SQL;
  EXECUTE DYNAMIC_QUERY;
  DEALLOCATE PREPARE DYNAMIC_QUERY;
END $$
DELIMITER ;

#스토어드 프로시저 실행
CALL DOIT_DYNAMIC('PAYMENT', '*', 1);
  

[인덱스]
#인덱스의 종류: 클러스터형 인덱스, 비클러스터형 인덱스

#인덱스 생성 및 삭제하기
1. 실습을 위한 테이블과 데이터 생성
USE DOITSQL;

DROP TABLE IF EXISTS DOIT_CLUSTERINDEX;
CREATE TABLE DOIT_CLUSTRINDEX (
COL_1 INT,
COL_2 VARCHAR(50),
COL_3 VARCHAR(50)
);

INSERT INTO DOIT_CLUSTERINDEX VALUES (2, '사자', 'LION');
INSERT INTO DOIT_CLUSTERINDEX VALUES (5, '호랑이', 'TIGER');
INSERT INTO DOIT_CLUSTERINDEX VALUES (3, '얼룩말', ZBERA');
INSERT INTO DOIT_CLUSTERINDEX VALUES (4, '코뿔소', 'RHINOCEROS');
INSERT INTO DOIT_CLUSTERINDEX VALUES (1, '거북이', 'TURTLE');

SELECT * FROM DOIT_CLUSTERINDEX;

2. 기본키(기본 인덱스) 생성
ALTER TABLE DOIT_CLUSTERINDEX
  ADD CONSTRAINT KEY (COL_1);

SELECT * FROM DOIT_CLUSTERINDEX;

3. 새로운 데이터 입력
INSERT INTO DOIT_CLUSTERINDEX VALUES (0, '물고기', 'FISH');
SELECT * FROM DOIT_CLUSTERINDEX;

4. COL_2 열로 인덱스 변경
ALTER TABLE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY DOIT_CLUSTERINDEX (COL_2);

SELECT * FROM DOIT_CLUSTERINDEX;

5. COL_3 열로 인덱스 변경
ALTER TALBE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY (COL_3);

SELECT * FROM DOIT_CLUSTERINDEX;

6. 복합키 인덱스 생성
ALTER TABLE DOIT_CLUSTERINDEX
  DROP PRIMARY KEY,
  ADD CONSTRAINT PRIMARY KEY (COL_1, COL_3);

SHOW INDEX FROM DOIT_CLUSTERINDEX;

7. 인덱스 삭제
ALTER TABLE DOIR_CLUSTERINDEX DROP PRIMARY KEY;

SHOW INDEX FROM DOIT_CLUSTERINDEX;
